- Single flight mutations
- Internal structure of solidstart


SOLID: createEffect vs createMemo (with gotchas)

Mental model
- Solid tracks dependencies by “READS”.
- A reactive computation (effect/memo/JSX expression) runs once initially, then re-runs when any signals it READ changed.

createMemo(fn)
- Purpose: derive + cache a value.
- Think: “computed signal”.
- Runs fn once initially, caches the result.
- Recomputes ONLY when signals read inside fn change.
- Returns a READ-ONLY accessor: memo() -> value.
- Key benefit: if memo() is read in many places, Solid computes it ONCE per change, then shares the result.
- Use for: filtered lists, computed totals, formatted strings, expensive calculations, expensive DOM creation results.

Gotchas (createMemo)
- Don’t try to “set” a memo; it’s read-only.
- Memo should be pure (no side effects inside). Keep network calls / localStorage / DOM mutations out of memos.
- Memo only tracks signals you read inside it. If you forget to read a signal, it won’t update.

Rule: “What can be derived, should be derived.”
- If value = function(other state), prefer createMemo over “effect writes into another signal”.

createEffect(fn)
- Purpose: run SIDE EFFECTS when dependencies change.
- Examples: API calls, logging/analytics, localStorage, timers, subscriptions, websocket, imperative DOM work (focus/measure), integrating non-Solid libs.
- Runs once initially, then re-runs when any signals read inside fn change.
- Common pattern: read some signal(s) -> perform side effect -> set another signal with result.

Gotchas (createEffect)
- Effects re-run based on what they READ, not what they WRITE.
  - Writing setUser(...) does NOT retrigger an effect unless that effect also reads user().
- Infinite loops happen when an effect reads a signal that it (directly or indirectly) writes.
  - Direct loop: read user() then setUser(...)
  - Indirect loop: effect A sets userId from user; effect B fetches user from userId -> can cycle.
- Async fetching gotcha: rapid changes can trigger multiple requests; you may need cancellation, debouncing, or “ignore stale responses”.
- Avoid using createEffect to maintain derived state:
  - Anti-pattern: createEffect(() => setTotal(calc(items())))
  - Prefer: const total = createMemo(() => calc(items()))

How JSX updates relate
- Each JSX expression {...} behaves like a tiny reactive computation.
- If it returns text: Solid updates the text node only.
- If it changes attributes: Solid updates only those attributes.
- If it conditionally returns different elements: Solid swaps only the affected child nodes, not the entire component.

Tips to prevent accidental reactivity / loops
- Dependency tracking is by reads; be intentional about what you read inside effects.
- If you must read something in an effect but don’t want it to trigger reruns, use untrack(() => ...)
- Keep “source of truth” signals separate from “derived” values (use memos for derived).
- Prefer createResource for data fetching patterns when possible (cleaner than manual effect + setSignal).

Quick decision guide
- “I need a value computed from other signals” -> createMemo
- “I need to do something external when signals change” -> createEffect
- “I’m fetching data based on a signal” -> createResource (often) or createEffect with async safeguards


SOLID Best Practices: Signals, Effects, Memos (Do’s / Don’ts)

Core mental model
- Solid tracks dependencies by READS.
- Any reactive computation runs once initially, then re-runs when signals it READ changes.
- Keep “real state” minimal. Derive everything else.

1) Signals (createSignal)
What they are
- Source-of-truth state holders: user input, server results, external events.

DO
- Store only real state (things you can’t derive).
  Examples: selectedId, queryText, itemsFromServer, userProfile, authToken.
- Keep signals small and focused (avoid giant “appState” objects unless needed).
- Prefer immutable updates for arrays/objects (create new arrays/objects).
  - setItems(prev => [...prev, newItem])
  - setUser(prev => ({ ...prev, name: "X" }))
- Name accessors clearly:
  - const [user, setUser] = createSignal(null)

DON’T
- Don’t store derived values as signals (total, filtered list, fullName, isValid).
  Use createMemo instead.
- Don’t set signals in ways that depend on reading & writing the same signal without guards.
- Don’t mutate objects/arrays in place and expect reactivity without setting a new reference.

2) Memos (createMemo)
What they are
- Cached computed values (read-only signals).
- “Compute once per change, share everywhere.”

DO
- Use memos for derived values:
  - filtered/sorted lists, counts, totals, formatting, mapping view models.
- Keep memo functions PURE:
  - only READ signals/memos and RETURN a value.
- Use memos to avoid duplicated expensive work:
  - compute once even if used in multiple places (JSX + other logic).

DON’T
- Don’t do side effects in memos:
  - no fetch, no localStorage writes, no subscriptions, no DOM manipulation.
- Don’t call setters in memos (directly or via helper functions).
  - This can create circular updates and unpredictable behavior.
- Don’t “force” memos to run; they should be derived naturally from reads.

Rule
- If it can be computed from existing state: createMemo.
- “What can be derived, should be derived.”

3) Effects (createEffect)
What they are
- Reactive side-effect runners.
- Runs once initially; re-runs when dependencies (signals read inside) change.

DO
- Use effects for SIDE EFFECTS:
  - API calls / createResource alternative
  - logging / analytics
  - localStorage reads/writes
  - timers, subscriptions, websockets
  - imperative DOM work (focus, measure)
- Read only what should trigger the effect (be intentional).
- Add guards to avoid unnecessary work:
  - if (!id) return;
  - if (prev === next) return;
- For async work, handle “stale responses”:
  - track request id / abort controller / ignore out-of-date results.

DON’T
- Don’t use effects to create derived state:
  - Anti-pattern: createEffect(() => setTotal(calc(items())))
  - Prefer: const total = createMemo(() => calc(items()))
- Don’t accidentally read signals you write (common loop source).
  - Effects re-run based on READS, not WRITES.
  - But if you read X() and setX(...), that’s a loop risk.
- Don’t put too many dependencies in one effect; split effects by responsibility.

4) Loop / gotcha checklist (most common bugs)
- Infinite loop usually means:
  - An effect or memo READS a signal that it (directly/indirectly) WRITES.
- Direct loop example (bad):
  - createEffect(() => setX(x() + 1))
- Indirect loop example (bad):
  - effect A: reads user() -> sets userId()
  - effect B: reads userId() -> fetch -> sets user()
- Fix patterns:
  - move “derived” to memo
  - add guard conditions
  - separate responsibilities into separate effects
  - use untrack(() => ...) when you must read something but don’t want it as a dependency

5) Practical decision guide
- “This value comes from user/server/outside world” -> Signal
- “This value can be computed from other state” -> Memo
- “I need to do something external when something changes” -> Effect
- “Fetch data when dependency changes” -> createResource (often best) or Effect with cancellation

6) Naming + organization tips
- Signals: noun (user, items, query)
- Setters: verb (setUser, setItems, setQuery)
- Memos: derived noun (filteredItems, totalPrice, fullName)
- Effects: group by side-effect type (storage effect, analytics effect, fetch effect)

Quick example (clean structure)
- signal: userId
- effect: fetch user when userId changes
- memo: derive fullName from user

const [userId, setUserId] = createSignal();
const [user, setUser] = createSignal(null);

createEffect(() => {
  const id = userId();
  if (!id) return;
  fetch(`/api/users/${id}`).then(r => r.json()).then(setUser);
});

const fullName = createMemo(() => user() ? `${user().first} ${user().last}` : "");
In Solid, a component function usually runs only once (initial setup), so console.log at the top level
logs only once. Solid updates the UI via fine-grained reactivity without re-running the whole component. 
If you want a log to run on updates, put it inside a reactive context (e.g., createEffect 
or a JSX {...} expression) and make sure you READ signals inside it (count(), not count).

JSX lets you use JavaScript (if/map/etc.) inside templates. But Solid has no
Virtual DOM, so using items().map(...) for a reactive list can recreate DOM
nodes on updates, which is wasteful. Reactive libraries use “template helpers”
to update lists/conditionals efficiently without rebuilding everything. In
Solid, these helpers are provided as components like <For> (lists) and <Show>
(conditionals). They create nodes once and then add/remove/update only what
changed.

Example: list rendering

Less ideal (may recreate <li> nodes on updates):
<ul>
  {items().map(item => <li>{item.name}</li>)}
</ul>

Preferred in Solid (efficient updates):
<ul>
  <For each={items()}>
    {(item) => <li>{item.name}</li>}
  </For>
</ul>

Example: conditional rendering

Simple JS conditional:
{isLoggedIn() ? <Dashboard /> : <Login />}

Preferred in Solid (clear + efficient helper):
<Show when={isLoggedIn()} fallback={<Login />}>
  <Dashboard />
</Show>

Solid: <Switch> vs <Dynamic>

<Switch> = if / else-if / else for UI
- Use when you want to show ONE of many UI states based on conditions.
- Solid renders the FIRST <Match> whose `when` is true; otherwise renders `fallback`.

Example:
import { Switch, Match } from "solid-js";

<Switch fallback={<div>Idle</div>}>
  <Match when={loading()}><div>Loading...</div></Match>
  <Match when={error()}><div>Error!</div></Match>
  <Match when={data()}><div>Show data</div></Match>
</Switch>

<Dynamic> = choose the component/tag itself at runtime
- Use when the TYPE of element/component changes (button vs link, h1 vs h2, etc.).

Example:
import { Dynamic } from "solid-js/web";

<Dynamic component={isLink() ? "a" : "button"} href="/home">
  Go
</Dynamic>

Rule of thumb:
- Choosing between conditions (states) -> <Switch>
- Choosing which component/tag to render -> <Dynamic>
============================================================================================

Solid: onCleanup (summary)

onCleanup lets you register cleanup code anywhere in Solid’s reactive system.
It runs in two cases:
1) Before a reactive scope re-runs (e.g., an effect re-executes because a
   dependency changed).
2) When that scope is disposed (e.g., component unmount, <Show> branch removed,
   list item removed in <For>/<Index>).

Use onCleanup to stop/undo things you started:
- remove event listeners
- clear timers/intervals
- unsubscribe from websockets/subscriptions
- abort in-flight fetch requests
- dispose 3rd-party library instances

Example A: createEffect + onCleanup (timer)
import { createSignal, createEffect, onCleanup } from "solid-js";

const [count, setCount] = createSignal(0);

createEffect(() => {
  console.log("effect run, count =", count()); // dependency

  const t = setInterval(() => setCount(c => c + 1), 1000);

  onCleanup(() => {
    console.log("cleanup before re-run or dispose");
    clearInterval(t);
  });
});

Example B: createEffect + onCleanup (abort fetch on changes)
import { createEffect, onCleanup } from "solid-js";

createEffect(() => {
  const id = userId(); // dependency

  const controller = new AbortController();
  fetch(`/api/users/${id}`, { signal: controller.signal });

  onCleanup(() => {
    // runs before effect re-runs OR when effect is disposed
    controller.abort();
  });
});

Example C: Component + onCleanup (event listener)
import { onMount, onCleanup } from "solid-js";

function MyComp() {
  const onResize = () => console.log("resized");

  onMount(() => window.addEventListener("resize", onResize));

  onCleanup(() => {
    // runs when component is removed from the DOM
    window.removeEventListener("resize", onResize);
  });

  return <div>Resize the window</div>;
}

==============================================================================

Solid: ref callback (summary)

A ref callback is a function you pass to `ref` so Solid can give you the real
DOM element when it is created.

Basic example (store single element ref):
let el;
return <input ref={(node) => (el = node)} />;

- Solid calls the callback with the DOM node when the element is created.
- After that, you can use `el` (focus, measure, scroll, etc.).

Example (log timing):
let el;
return (
  <div
    ref={(node) => {
      el = node;
      console.log("ref assigned, isConnected =", node.isConnected);
    }}
  />
);

Example (refs in a list using a Map):
const els = new Map();

<For each={items()}>
  {(item) => (
    <li ref={(node) => els.set(item.id, node)}>
      {item.name}
    </li>
  )}
</For>

// later:
els.get(someId)?.scrollIntoView();

Cleanup pattern (remove ref when item unmounts):
import { onCleanup } from "solid-js";

const els = new Map();

<For each={items()}>
  {(item) => (
    <li
      ref={(node) => {
        els.set(item.id, node);
        onCleanup(() => els.delete(item.id));
      }}
    >
      {item.name}
    </li>
  )}
</For>


=================================================================

Where cleanup can occur in Solid (with examples)

Key rule:
- onCleanup is tied to the reactive scope where you call it.
- Cleanup runs when that scope is:
  (1) re-run (effects/computations), or
  (2) disposed (component/branch/list/root removed).

1) Component cleanup (runs on unmount/disposal)
- Trigger: component removed from DOM (route change, <Show> off, parent stops rendering)
import { onCleanup } from "solid-js";

function Comp() {
  onCleanup(() => console.log("component disposed"));
  return <div />;
}

2) Effect cleanup (createEffect)
- Trigger: before effect re-runs (dependency changes) AND when disposed
import { createEffect, onCleanup } from "solid-js";

createEffect(() => {
  const id = userId();              // dependency
  const sub = subscribeToUser(id);  // setup
  onCleanup(() => sub.unsubscribe()); // cleanup old before rerun / on dispose
});

3) Conditional branch cleanup (<Show>, <Switch>/<Match>)
- Trigger: branch removed (condition changes)
import { Show, onCleanup } from "solid-js";

function Child() {
  onCleanup(() => console.log("child branch disposed"));
  return <div>Child</div>;
}

<Show when={open()}>
  <Child />
</Show>

4) List item cleanup (<For>, <Index>)
- Trigger: item removed (delete) or recreated due to list changes
import { For, onCleanup } from "solid-js";

function Row() {
  onCleanup(() => console.log("row disposed"));
  return <li>Row</li>;
}

<For each={items()}>
  {(item) => <Row item={item} />}
</For>

5) Manual root cleanup (createRoot)
- Trigger: calling dispose() cleans everything under the root
import { createRoot, onCleanup } from "solid-js";

const dispose = createRoot(() => {
  onCleanup(() => console.log("root disposed"));
});

// later
dispose();

Notes:
- Effects: cleanup happens on dependency changes (reruns) + final dispose.
- Components/branches/lists: cleanup happens when removed from render tree.

===============================================================================


Directive accessor updates vs event listener re-registration (Solid)

Key point:
- A directive function (clickOutside(el, accessor)) runs ONCE when the element is
  created.
- document.addEventListener(...) is executed ONCE at that time.
- When the value passed to the directive changes, Solid does NOT re-run the
  directive and does NOT automatically remove/re-add the listener.

Why the handler still uses the latest value:
- `accessor` is a function (getter). The event handler calls accessor() at click
  time, so it always reads the latest value/callback.

Example (no re-register needed):
function clickOutside(el, accessor) {
  const onDocClick = (e) => {
    const cb = accessor();              // reads latest callback/value
    if (cb && !el.contains(e.target)) cb(e);
  };

  document.addEventListener("click", onDocClick);

  onCleanup(() => {
    document.removeEventListener("click", onDocClick);
  });
}

- If accessor() changes (new callback), the SAME onDocClick is still registered,
  but it calls the NEW callback because accessor() returns the latest one.
- onCleanup runs ONLY when the element is disposed (unmounted/removed), not when
  accessor changes.

When you DO need to re-register the listener:
- if wiring depends on reactive values (enabled/disabled, event type, target,
  capture/passive options), use createEffect to add/remove.

Example (re-register on changes):
import { createEffect, onCleanup } from "solid-js";

function clickOutside(el, accessor) {
  createEffect(() => {
    const opts = accessor();            // reactive options
    if (!opts?.enabled) return;

    const handler = (e) => {
      const cb = accessor()?.onOutside; // latest callback
      if (cb && !el.contains(e.target)) cb(e);
    };

    document.addEventListener(opts.event ?? "click", handler, opts.capture);

    onCleanup(() => {
      document.removeEventListener(opts.event ?? "click", handler, opts.capture);
    });
  });
}

- Here, changing enabled/event/capture causes the effect to re-run:
  cleanup removes old handler, then a new handler is added.


=====================================================================================

Solid: mergeProps + splitProps (purpose + gotchas) with examples

Why these exist (reactivity gotcha):
- Solid props are reactive. If you destructure/spread like plain JS objects,
  you can "snapshot" values and lose updates.

BAD (breaks reactivity: snapshot):
function Comp(props) {
  const { name } = props;     // snapshot
  return <div>{name}</div>;   // won’t update if props.name changes
}

GOOD (keep reactivity):
function Comp(props) {
  return <div>{props.name}</div>;
}

1) mergeProps
Purpose:
- Add default props / combine prop sources WITHOUT losing reactivity.
- Safer than { ...defaults, ...props } which snapshots values.

Example (defaults + reactive):
import { mergeProps } from "solid-js";

function Button(rawProps) {
  const props = mergeProps({ type: "button", disabled: false }, rawProps);
  return (
    <button type={props.type} disabled={props.disabled}>
      {props.children}
    </button>
  );
}

Gotchas:
- Order matters: later sources override earlier.
  - mergeProps(defaults, props) ✅ parent overrides defaults
  - mergeProps(props, defaults) ❌ defaults override parent
- Don’t destructure merged props into variables (snapshot):
  const { disabled } = props; ❌ (use props.disabled)

2) splitProps
Purpose:
- Split props into groups (local component props vs “rest” DOM props) while
  keeping them reactive. Great for prop forwarding.

Example (local vs rest):
import { splitProps } from "solid-js";

function Input(allProps) {
  const [local, rest] = splitProps(allProps, ["label", "error"]);
  return (
    <label>
      <span>{local.label}</span>
      <input {...rest} />
      {local.error && <div class="error">{local.error}</div>}
    </label>
  );
}

Gotchas:
- Don’t destructure local/rest into plain variables (snapshot):
  const { label } = local; ❌ (use local.label)

Common best-practice pattern (defaults + local/rest):
import { mergeProps, splitProps } from "solid-js";

function Button(rawProps) {
  const merged = mergeProps({ variant: "primary", type: "button" }, rawProps);
  const [local, rest] = splitProps(merged, ["variant"]);
  return (
    <button class={`btn ${local.variant}`} {...rest}>
      {rest.children}
    </button>
  );
}

Rule of thumb:
- Defaults/combining props -> mergeProps
- Splitting local props from forwarded DOM props -> splitProps
- Avoid destructuring props into variables; prefer props.x or local.x
===========================================================================

Solid: children() helper (purpose + gotchas) with examples

Purpose:
- props.children can be many shapes (string, node, array, nested arrays/fragments,
  or even a function). The `children()` helper resolves/normalizes children and
  keeps reactivity.
- Use it when you need to inspect/transform children (count, map, fallback,
  wrap, filter).

Basic usage:
import { children } from "solid-js";

const c = children(() => props.children); // c is an accessor
// use c() to get resolved children

Example 1: simple render (children() not required)
function Card(props) {
  return <div class="card">{props.children}</div>;
}

Example 2: fallback if no children
import { children } from "solid-js";

function Panel(props) {
  const c = children(() => props.children);
  return <div>{c() ? c() : <div>No content</div>}</div>;
}

Example 3: map/wrap children (convert to array)
import { children } from "solid-js";

function Stack(props) {
  const c = children(() => props.children);
  const arr = () => c.toArray(); // normalized array of child nodes

  return (
    <div class="stack">
      {arr().map((node) => <div class="item">{node}</div>)}
    </div>
  );
}

Gotchas:
1) props.children might be a function (lazy/reactive children)
- children() resolves it correctly.
  <MyComp>{() => <Expensive />}</MyComp>

2) Keep reactivity: don’t destructure children from props (snapshot)
BAD:
  const { children } = props; // snapshot-ish
GOOD:
  const c = children(() => props.children);

3) c is an accessor: use c() inside render/effects (don’t precompute once if you
   need updates).
GOOD:
  return <div>{c()}</div>

Rule of thumb:
- Just render children -> {props.children} is fine
- Inspect/transform/count/fallback/map children -> use children(() => props.children)

=========================================================================================

Solid: createStore (purpose + use cases) with examples

Purpose:
- createStore is for structured state (objects/arrays/nested data).
- It gives a reactive proxy to read like normal JS (state.user.name) and a setter
  that can update deep paths (setState("user","name","X")).
- Fine-grained updates: only the parts you read update when they change.
- Avoids heavy object/array spreading for deep updates.

When to use createStore vs createSignal:
- createStore: lots of fields, nested objects/arrays, frequent deep updates.
- createSignal: simple primitives or you replace the whole value often.

1) Object store (forms/settings)
import { createStore } from "solid-js/store";

const [form, setForm] = createStore({
  name: "",
  email: "",
  address: { city: "", zip: "" }
});

setForm("name", "Tinshu");
setForm("address", "city", "Fredericton");

2) Array of objects store (todos/rows)
import { createStore } from "solid-js/store";

const [todos, setTodos] = createStore([
  { id: 1, text: "Buy milk", done: false },
  { id: 2, text: "Learn Solid", done: true }
]);

// update by index
setTodos(0, "done", true);

// update by predicate (find item by condition)
setTodos(t => t.id === 2, "text", "Learn SolidJS deeply");

// add new item (append at end)
setTodos(todos.length, { id: 3, text: "Ship app", done: false });

3) Nested arrays (board/columns/cards)
import { createStore } from "solid-js/store";

const [board, setBoard] = createStore({
  columns: [
    { id: "todo", cards: [{ id: 1, title: "Task A" }] },
    { id: "doing", cards: [{ id: 2, title: "Task B" }] }
  ]
});

// update nested field
setBoard("columns", 0, "cards", 0, "title", "Task A (updated)");

4) Heavy nested object (deep config / big JSON)
import { createStore } from "solid-js/store";

const [state, setState] = createStore({
  user: {
    id: 10,
    profile: {
      preferences: {
        theme: "dark",
        notifications: { email: true, sms: false }
      }
    }
  },
  org: {
    tenants: [
      { id: 1, config: { flags: { beta: false } } },
      { id: 2, config: { flags: { beta: true } } }
    ]
  }
});

// deep object update
setState("user", "profile", "preferences", "theme", "light");

// deep update inside array-of-objects
setState("org", "tenants", t => t.id === 1, "config", "flags", "beta", true);

Gotchas:
- Don’t destructure store fields (can lose reactivity):
  BAD: const { user } = state;
  GOOD: state.user.profile.preferences.theme
- createStore is great for deep updates; if you always replace whole objects,
  createSignal may be simpler.
===========================================================================
Solid createStore setter: undefined + array index special cases (summary)

1) Setting a store key to undefined deletes the key
- In Solid stores, undefined is treated as "remove this property".
Example:
setState({ middleName: undefined }); // deletes middleName key

Gotcha:
- You cannot reliably keep the key and store an "undefined" value in a store,
  because the store interprets it as deletion.

If you want "empty but not deleted", use one of these:

A) Use null (most common)
setState({ middleName: null }); // key stays, value is empty

B) Use empty string (forms)
setState({ middleName: "" }); // key stays

C) Use a separate flag (clear intent)
setState({ middleName: "", hasMiddleName: false });

D) Use a sentinel value (distinguish missing vs intentionally blank)
const UNSET = Symbol("UNSET");
setState({ middleName: UNSET });

Rule:
- Avoid using undefined as a meaningful stored value in createStore.

2) Array append with setStore(length, value)
- For an array store, setStore(index, value) sets that array slot.
- Using length targets the next free index => append.
Example:
setTodos(todos.length, { id: 3, text: "Ship app", done: false }); // append

3) What if someone sets arr.length + 2 (skipping indexes)
Example:
setTodos(todos.length + 2, newTodo);

Behavior:
- Creates a sparse array (holes/empty slots) between old end and new index.
- Array length increases to newIndex + 1.
Example result (conceptually):
[ item0, item1, item2, <empty>, <empty>, newTodo ]

Gotchas:
- UI loops (<For>/<Index>) may now see undefined entries and can crash if you
  assume items exist (e.g., todo().text when todo() is undefined).
- Can render blank rows or cause inconsistent behavior.
- Generally avoid skipping indexes unless you intentionally want holes.

Best practice:
- Append: setTodos(todos.length, item)
- Insert/remove/reorder: use produce + splice-like logic instead of creating holes.

============================================================================================